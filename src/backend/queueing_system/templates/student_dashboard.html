{% extends 'base.html' %}

{% block title %}Student Dashboard{% endblock %}

{% block content %}
<div class="container mt-4">
    <h2 class="text-center mb-4">Welcome, {{ user.username }}, ({{ user.user_type }}, PC Number:{{ user.pc_number }}, Lab ID:{{ user.lab_id }})</h2>


    <div class="section-box mb-4">
        <h3>Your Help Requests</h3>
        <p>Help requests you make will appear here:</p>
        <ul id="help-requests-list">
            {% for request in help_requests %}
            <li id="request-{{ request.id }}" class="request-item">
                {{ request.description }} -
                Status: <b><span class="status">{{ request.status }}</span></b>
                <span class="queue-position">
                    {% if request.status in "pending,in_progress" and request.queue_position %}
                        (Position in queue: {{ request.queue_position }})
                    {% endif %}
                </span>    
                {% if request.status == "pending" and request.estimated_wait_time %}
                    <span class="wait-time">Estimated wait: {{ request.estimated_wait_time }} minutes</span>
                {% endif %}            
                {% if request.status == "pending" %}
                    <button class="cancel-request" data-request-id="{{ request.id }}">Cancel</button>
                {% elif request.status == "in_progress" %}
                    <button class="cancel-request" data-request-id="{{ request.id }}">Cancel</button>
                {% endif %}
            </li>
            {% endfor %}
        </ul>        
    </div>

    <div class="section-box">
        <h3>Need Help?</h3>
        <a href="{% url 'submit_request' %}" class="btn submit-button">Submit a New Help Request</a>
    </div>

    <div class="section-box">
        <h3>Notifications</h3>
        <ul id="notification-list"></ul>
    </div>
</div>

<script>
    // Connect to the WebSocket for student dashboard updates through the url '/ws/dashboard/'
    function connectWebSocket(url, onMessage) {
        let socket = new WebSocket('ws://' + window.location.host + '/ws/dashboard/');
        
        // 'onopen' event handler for when the WebSocket connection is established
        socket.onopen = function () {
            console.log("WebSocket connected to", url); // Output in the console that the connection was successful
        };
        
        // 'onmessage' event handler for when a message is received from the WebSocket
        socket.onmessage = onMessage;   // 'onMessage' passed as a parameter

        // 'onerror' event handler if there is an error with the WebSocket connection
        socket.onerror = function (error) {
            console.error("WebSocket error:", error);   // Output in the console that there was an error connecting to WebSocket
        };

        // 'onclose' event handler, for when the WebSocket connection is closed
        socket.onclose = function () {
            console.log("WebSocket disconnected. Reconnecting...");
            // Try to reconnect by calling the connectWebSocket function again after 5 seconds
            setTimeout(function () {
                connectWebSocket(url, onMessage); // Attempt to reconnect
            }, 5000); // Retry connection after 5 seconds
        };
        
        // Return the WebSocket object, allowing the user to interact with the connection
        return socket;
    }

    // WebSocket connection for dashboard updates
    const dashboardSocket = connectWebSocket(
        'ws://' + window.location.host + '/ws/dashboard/',
        function (event) {
            const data = JSON.parse(event.data);
            console.log("WebSocket message received:", data);
        
            // Display notification messages
            if (data.message) {
                const notificationList = document.getElementById("notification-list");
                const notificationItem = document.createElement("li");
                notificationItem.textContent = data.message;
                notificationList.appendChild(notificationItem);
            }
        
            // Handle status update messages
            if (data.type === 'status_update') {
                const requestId = data.request_id;
                const newStatus = data.new_status;
                const position = data.queue_position;
                const estimatedWaitTime = data.estimated_wait_time;
            
                const requestElement = document.getElementById(`request-${requestId}`);
                if (requestElement) {
                    // Update status text
                    const statusElement = requestElement.querySelector(".status");
                    if (statusElement) {
                        statusElement.textContent = newStatus;
                    }
                
                    // Update queue position
                    const positionElement = requestElement.querySelector(".queue-position");
                    if (newStatus === "pending") {
                        if (positionElement) {
                            if (position !== undefined && position !== null) {
                                positionElement.textContent = ` (Position in queue: ${position})`;
                            } else {
                                positionElement.textContent = "";
                            }
                        }
                    
                        // Add or update wait time element
                        let waitTimeElement = requestElement.querySelector(".wait-time");
                        if (!waitTimeElement) {
                            waitTimeElement = document.createElement("span");
                            waitTimeElement.classList.add("wait-time");
                            requestElement.appendChild(waitTimeElement);
                        }
                    
                        if (estimatedWaitTime !== undefined && estimatedWaitTime !== null) {
                            waitTimeElement.textContent = ` Estimated wait: ${estimatedWaitTime} minutes`;
                        } else {
                            waitTimeElement.textContent = "";
                        }
                    
                    } else {
                        // If status is in_progress or completed/canceled â€” clean up
                        if (positionElement) {
                            positionElement.textContent = "";
                        }
                    
                        const waitTimeElement = requestElement.querySelector(".wait-time");
                        if (waitTimeElement) {
                            waitTimeElement.remove();
                        }
                    
                        // Remove action buttons
                        const buttons = requestElement.querySelectorAll("button");
                        buttons.forEach(button => button.remove());
                    }
                }
            }
        }
    );

    // Add event listeners for dynamically generated buttons
    document.addEventListener("click", function (event) {
        const target = event.target;

        // Check if the clicked target has the class 'cancel-request'
        if (target.classList.contains("cancel-request")) {
            const requestId = target.getAttribute("data-request-id");   // If the target has the 'cancel-request' class, get the request ID associated with this target element
            fetch(`/cancel_request/${requestId}/`, { method: "POST", headers: { "X-CSRFToken": "{{ csrf_token }}" } })  // Use fetch to send a POST request to cancel the request on the WebSocket server. POST is used since an action is performed (cancelling a request). A CSRF token is included for security
                // Handle the response after the fetch call
                .then(response => {
                    // Check if the response was successful (status 200-299)
                    if (response.ok) {
                        console.log("Request canceled successfully.");  // Output a success message to the console
                    }
                });

        // If the clicked target does not have the class 'cancel-request', then check for 'mark-completed'
        } else if (target.classList.contains("mark-completed")) {
            const requestId = target.getAttribute("data-request-id");   // If the target has the 'mark-completed' class, get the request ID associated with this target element
            fetch(`/mark_completed/${requestId}/`, { method: "POST", headers: { "X-CSRFToken": "{{ csrf_token }}" } })  // Use fetch to send a POST request to cancel the request on the WebSocket server. POST is used since an action is performed (marking a request as completed). A CSRF token is included for security
                // Handle the response after the fetch call
                .then(response => {
                    // Check if the response was successful (status 200-299)
                    if (response.ok) {
                        console.log("Request marked as completed.");    // Output a success message to the console
                    }
                });
        }
    });
</script>


{% endblock %}
